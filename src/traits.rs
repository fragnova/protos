use crate::categories::{BinaryCategories, TextCategories};
use parity_scale_codec::{Compact, Decode, Encode, Input, Output};
use scale_info::prelude::{boxed::Box, vec::Vec};

#[cfg(feature = "std")]
use serde::{Deserialize, Serialize};

// For more info refer to:
// https://github.com/fragcolor-xyz/shards/blob/devel/include/shards.h

#[cfg(not(feature = "std"))]
type String = Vec<u8>;

/// Struct representing limits on numbers (such has min and max values)
/// Sadly SCALE supports only unsigned integers, so we need to wrap the limits to u64 and unwrap them when decoding.
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub struct Limits {
  /// The minimum value
  pub min: i64,
  /// The maximum value
  pub max: i64,
  /// Only used when we representing floating point numbers as integers
  /// The amount of scaling to apply to the fixed point value
  /// Convert the limit values to float by dividing the fixed point values with 10^scale.
  /// This allows us to derive a float representation of the limit values with the desired precision.
  pub scale: u32,
}

fn wrap_to_u64(x: i64) -> u64 {
  (x as u64).wrapping_add(u64::MAX / 2 + 1)
}

fn to_i64(x: u64) -> i64 {
  ((x as i64) ^ (1 << 63)) & (1 << 63) | (x & (u64::MAX >> 1)) as i64
}

impl Encode for Limits {
  fn encode_to<W: Output + ?Sized>(&self, dest: &mut W) {
    Compact(wrap_to_u64(self.min)).encode_to(dest);
    Compact(wrap_to_u64(self.max)).encode_to(dest);
    Compact(self.scale).encode_to(dest);
  }
}

impl Decode for Limits {
  fn decode<I: Input>(input: &mut I) -> Result<Self, parity_scale_codec::Error> {
    Ok(Self {
      min: to_i64(Compact::<u64>::decode(input)?.into()),
      max: to_i64(Compact::<u64>::decode(input)?.into()),
      scale: Compact::<u32>::decode(input)?.into(),
    })
  }
}

/// Enum that represents the type of Code.
///
/// There are only two possible types of code:
/// 1. Shard
/// 2. Wire
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Copy, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub enum CodeType {
  /// A collection of shards that can be injected into more complex blocks of code or wires.
  Shards,
  /// A single wire that can be executed.
  Wire {
    looped: Option<bool>,
    pure: Option<bool>,
  },
}

/// Struct that represents information about a Code.
///
/// Note: There are only two possible types of code: Shard and Wire.
/// See the `CodeType` enum for more information.
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub struct CodeInfo {
  /// The type of code, either Shard or Wire.
  pub kind: CodeType,
  /// A list of variables that must be available to the code context before the code can be executed.
  /// Each variable is represented as a tuple of its name and its type.
  pub requires: Vec<(String, VariableType)>,
  /// A list of variables that are available in the code context.
  /// Each variable is represented as a tuple of its name and its type.
  pub exposes: Vec<(String, VariableType)>,
  /// A list of variable types that are inputted into the code.
  pub inputs: Vec<VariableType>,
  /// The variable type of the output generated by the code.
  pub output: VariableType,
}

#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub struct TableInfo {
  /// The names of the keys. An empty key represents any name and allows multiple instances of the corresponding index type.
  pub keys: Vec<String>,
  /// The types expected for each key, following the keys array (should be the same length).
  pub types: Vec<Vec<VariableType>>,
}

/// Enum represents all the possible types that a variable can be
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub enum VariableType {
  // No type
  None,
  // Any type
  Any,
  // Boolean type
  Bool,
  // Color type (vector of 4 8-bit unsigned integers)
  Color,
  // Binary data type
  Bytes(Option<BinaryCategories>),
  // String type
  String(Option<TextCategories>),
  // Image type
  Image,
  // Audio type
  Audio,
  // Shards Mesh type
  Mesh,

  // Enum type with vendor ID and type ID
  Enum {
    #[codec(compact)]
    vendor_id: u32,
    #[codec(compact)]
    type_id: u32,
  },

  // Integer type with optional limits
  Int(Option<Limits>),
  // Vector of 2 integers with optional limits
  Int2([Option<Limits>; 2]),
  // Vector of 3 integers with optional limits
  Int3([Option<Limits>; 3]),
  // Vector of 4 integers with optional limits
  Int4([Option<Limits>; 4]),
  // Vector of 8 integers with optional limits
  Int8([Option<Limits>; 8]),
  // Vector of 16 integers with optional limits
  Int16([Option<Limits>; 16]),

  // Float type with optional limits
  Float(Option<Limits>),
  // Vector of 2 floats with optional limits
  Float2([Option<Limits>; 2]),
  // Vector of 3 floats with optional limits
  Float3([Option<Limits>; 3]),
  // Vector of 4 floats with optional limits
  Float4([Option<Limits>; 4]),

  // Sequence of variable types with optional length limits
  Seq {
    types: Vec<VariableType>,
    length_limits: Option<Limits>,
  },

  // Table type
  Table(TableInfo),

  // Object type with vendor ID and type ID
  Object {
    #[codec(compact)]
    vendor_id: u32,
    #[codec(compact)]
    type_id: u32,
  },

  // Code type with information
  Code(Box<CodeInfo>),
  // Channel type with variable type
  Channel(Box<VariableType>),
  // Event type with variable type
  Event(Box<VariableType>),
}

/// Struct contains information about a variable type
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub struct VariableTypeInfo {
  /// The variable type
  #[cfg_attr(feature = "std", serde(alias = "type"))]
  pub type_: VariableType,
  /// Raw-bytes representation of the default value of the variable type (optional)
  pub default: Option<Vec<u8>>,
}

#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub struct Record {
  pub name: String,
  pub types: Vec<VariableTypeInfo>,
}

impl From<(String, Vec<VariableTypeInfo>)> for Record {
  fn from((name, types): (String, Vec<VariableTypeInfo>)) -> Self {
    Self { name, types }
  }
}

/// Struct represents a Trait
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
pub struct Trait {
  /// Name of the Trait
  pub name: String,
  /// Revision of the Trait
  #[codec(compact)]
  pub revision: u32,
  /// List of attributes of the Trait. An attribute is represented as a **tuple that contains the attribute's name and the attribute's type**.
  pub records: Vec<Record>,
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::categories::TextCategories;

  #[test]
  fn encode_decode_simple_1() {
    let mut trait1: Vec<Record> = vec![(
      "int1".to_string(),
      vec![VariableTypeInfo {
        type_: VariableType::Int(None),
        default: None,
      }],
    )
      .into()];

    // THIS IS the way we reprocess the trait declaration before sorting it on chain and hashing it
    trait1 = trait1
      .into_iter()
      .map(|r| (r.name.to_lowercase(), r.types).into())
      .collect();
    trait1.dedup_by(|a, b| a.name == b.name);
    // Note: "Strings are ordered lexicographically by their byte values ... This is not necessarily the same as “alphabetical” order, which varies by language and locale". Source: https://doc.rust-lang.org/std/primitive.str.html#impl-Ord-for-str
    trait1.sort_by(|a, b| a.name.cmp(&b.name));

    let trait1 = Trait {
      name: "Trait1".to_string(),
      revision: 1,
      records: trait1,
    };

    let e_trait1 = trait1.encode();

    let d_trait1 = Trait::decode(&mut e_trait1.as_slice()).unwrap();

    assert!(trait1 == d_trait1);
  }

  #[test]
  fn encode_decode_boxed_1() {
    let mut trait1: Vec<Record> = vec![
      (
        "int1".to_string(),
        vec![VariableTypeInfo {
          type_: VariableType::Int(None),
          default: None,
        }],
      )
        .into(),
      (
        "boxed1".to_string(),
        vec![VariableTypeInfo {
          type_: VariableType::Code(Box::new(CodeInfo {
            kind: CodeType::Wire {
              looped: None,
              pure: None,
            },
            requires: vec![("int1".to_string(), VariableType::Int(None))],
            exposes: vec![],
            inputs: vec![],
            output: VariableType::None,
          })),
          default: None,
        }],
      )
        .into(),
    ];

    // THIS IS the way we reprocess the trait declaration before sorting it on chain and hashing it
    trait1 = trait1
      .into_iter()
      .map(|r| (r.name.to_lowercase(), r.types).into())
      .collect();
    trait1.dedup_by(|a, b| a.name == b.name);
    trait1.sort_by(|a, b| a.name.cmp(&b.name));

    let trait1 = Trait {
      name: "Trait1".to_string(),
      revision: 1,
      records: trait1,
    };

    let e_trait1 = trait1.encode();

    let d_trait1 = Trait::decode(&mut e_trait1.as_slice()).unwrap();

    assert!(trait1 == d_trait1);
    assert!(d_trait1.records[0].name == "boxed1".to_string());
    let type_ = &d_trait1.records[0].types[0].type_;
    let requires = match type_ {
      VariableType::Code(code) => &code.requires,
      _ => panic!("Should be a code"),
    };
    assert!(requires[0].0 == "int1".to_string());
  }

  #[test]
  fn test_json_simple_1() {
    let mut trait1: Vec<Record> = vec![(
      "int1".to_string(),
      vec![VariableTypeInfo {
        type_: VariableType::Int(None),
        default: None,
      }],
    )
      .into()];

    // THIS IS the way we reprocess the trait declaration before sorting it on chain and hashing it
    trait1 = trait1
      .into_iter()
      .map(|r| (r.name.to_lowercase(), r.types).into())
      .collect();
    trait1.dedup_by(|a, b| a.name == b.name);
    trait1.sort_by(|a, b| a.name.cmp(&b.name));

    let trait1 = Trait {
      name: "Trait1".to_string(),
      revision: 1,
      records: trait1,
    };

    let e_trait1 = serde_json::to_string(&trait1).unwrap();

    let d_trait1: Trait = serde_json::from_str(&e_trait1).unwrap();

    assert!(trait1 == d_trait1);
  }

  #[test]
  fn test_json_boxed_1() {
    let mut trait1: Vec<Record> = vec![
      (
        "int1".to_string(),
        vec![VariableTypeInfo {
          type_: VariableType::Int(None),
          default: None,
        }],
      )
        .into(),
      (
        "boxed1".to_string(),
        vec![VariableTypeInfo {
          type_: VariableType::Code(Box::new(CodeInfo {
            kind: CodeType::Wire {
              looped: None,
              pure: None,
            },
            requires: vec![("int1".to_string(), VariableType::Int(None))],
            exposes: vec![],
            inputs: vec![],
            output: VariableType::None,
          })),
          default: None,
        }],
      )
        .into(),
    ];

    // THIS IS the way we reprocess the trait declaration before sorting it on chain and hashing it
    trait1 = trait1
      .into_iter()
      .map(|r| (r.name.to_lowercase(), r.types).into())
      .collect();
    trait1.dedup_by(|a, b| a.name == b.name);
    trait1.sort_by(|a, b| a.name.cmp(&b.name));

    let trait1 = Trait {
      name: "Trait1".to_string(),
      revision: 1,
      records: trait1,
    };

    let e_trait1 = serde_json::to_string(&trait1).unwrap();

    let d_trait1: Trait = serde_json::from_str(&e_trait1).unwrap();

    assert!(trait1 == d_trait1);
    assert!(d_trait1.records[0].name == "boxed1".to_string());
    let type_ = &d_trait1.records[0].types[0].type_;
    let requires = match type_ {
      VariableType::Code(code) => &code.requires,
      _ => panic!("Should be a code"),
    };
    assert!(requires[0].0 == "int1".to_string());
  }

  #[test]
  fn test_json_textual_from_str() {
    let trait1 = Trait {
      name: "Trait1".to_string(),
      revision: 1,
      records: vec![(
        "int1".to_string(),
        vec![VariableTypeInfo {
          type_: VariableType::Int(None),
          default: None,
        }],
      )
        .into()],
    };

    let json_trait1 = r#"{
      "name": "Trait1",
      "revision": 1,
      "records": [
        {
          "name": "int1",
          "types": [
            {
              "type": {"Int": null},
              "default": null
            }
          ]
        }
      ]
    }"#;

    let d_trait1 = serde_json::from_str(&json_trait1).unwrap();

    assert!(trait1 == d_trait1);
  }

  #[test]
  fn test_json_textual_from_str_ambal() {
    let json_trait1 = r#"{
      "name": "AmbalLoreFragment",
      "revision": 1,
      "records": [
        {
          "name": "banner",
          "types": [
            {"type": "Image"}
          ]
        },
        {
          "name": "content",
          "types": [
            {"type": {"String": "markdown"}}
          ]
        }
      ]
    }"#;

    let d_trait1 = serde_json::from_str(&json_trait1).unwrap();

    let trait1 = Trait {
      name: "AmbalLoreFragment".to_string(),
      revision: 1,
      records: vec![
        (
          "banner".to_string(),
          vec![VariableTypeInfo {
            type_: VariableType::Image,
            default: None,
          }
          .into()],
        )
          .into(),
        (
          "content".to_string(),
          vec![VariableTypeInfo {
            type_: VariableType::String(Some(TextCategories::Markdown)),
            default: None,
          }
          .into()],
        )
          .into(),
      ],
    };

    assert!(trait1 == d_trait1);
  }

  #[test]
  fn test_limits() {
    let limits = Limits {
      min: -100,
      max: 100,
      scale: 2,
    };

    let expected_min = -1.0;
    let expected_max = 1.0;

    // Convert the limit values to float by dividing the fixed point values with 10^scale.
    // This allows us to derive a float representation of the limit values with the desired precision.
    let float_min = limits.min as f64 / 10u64.pow(limits.scale) as f64;
    let float_max = limits.max as f64 / 10u64.pow(limits.scale) as f64;

    assert_eq!(float_min, expected_min);
    assert_eq!(float_max, expected_max);

    let encoded = limits.encode();
    let decoded = Limits::decode(&mut encoded.as_slice()).unwrap();
    assert!(limits == decoded);
  }
}
